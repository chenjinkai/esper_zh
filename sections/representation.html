<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="../stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../stylesheets/github-dark.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../stylesheets/print.css" media="print">
    <link rel="stylesheet" type="text/css" href="../stylesheets/styles.css" media="screen">

    <title>2.事件的声明</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>Esper Reference5.5.0文档翻译</h1>
        <h2>esper中文文档翻译</h2>
		<p>声明：此文档为本人翻译作品，可以免费阅读和共享，如有转载请注明出处，另外本文档不得用于商业目的。</p>
        <section id="downloads">
          <a href="https://github.com/chenjinkai/esper_zh/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/chenjinkai/esper_zh/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/chenjinkai/esper_zh" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
		<section id="main_content">
						<!--第二章-->
			<h3>
			   <a id="event-representations" class="anchor first-level-catalog" href="#event-representations" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2. 事件的声明
			 </h3>
			<div class="second-level-catalog"><a href="#2.1">2.1 基于java对象的事件</a></div>
			<div class="second-level-catalog"><a href="#2.2">2.2 事件属性</a></div>
			<div class="third-level-catalog"><a href="#2.2.1">2.2.1 转义符号</a></div>
			<div class="third-level-catalog"><a href="#2.2.2">2.2.2 表达式作为key或者索引下标</a></div>
			<div class="second-level-catalog"><a href="#2.3">2.3 动态事件属性</a></div>
			<div class="second-level-catalog"><a href="#2.4">2.4 片段（Fragment）与片段类型</a></div>
			<div class="second-level-catalog"><a href="#2.5">2.5 Plain-Old Java对象事件（Event）</a></div>
			<div class="third-level-catalog"><a href="#2.5.1">2.5.1 java对象事件属性</a></div>
			<div class="third-level-catalog"><a href="#2.5.2">2.5.2 属性名称</a></div>
			<div class="third-level-catalog"><a href="#2.5.3">2.5.3 泛型</a></div>
			<div class="third-level-catalog"><a href="#2.5.4">2.5.4 Indexed和Mapped属性的Setter方法</a></div>
			<div class="third-level-catalog"><a href="#2.5.5">2.5.5 已知限制</a></div>
			<div class="second-level-catalog"><a href="#2.6">2.6  java.util.Map事件</a></div>
			<div class="third-level-catalog"><a href="#2.6.1">2.6.1 概述</a></div>
			<div class="third-level-catalog"><a href="#2.6.2">2.6.2 Map 属性</a></div>
			<div class="third-level-catalog"><a href="#2.6.3">2.6.3 Map 父类型</a></div>
			<div class="third-level-catalog"><a href="#2.6.4">2.6.4 Map 高级属性类型</a></div>
			<div class="second-level-catalog"><a href="#2.7">2.7 对象数组（Object-array）事件</a></div>
			<div class="third-level-catalog"><a href="#2.7.1">2.7.1 概述</a></div>
			<div class="third-level-catalog"><a href="#2.7.2">2.7.2 对象数组属性</a></div>
			<div class="third-level-catalog"><a href="#2.7.3">2.7.3 对象数组父类</a></div>
			<div class="third-level-catalog"><a href="#2.7.4">2.7.4 对象数组高级属性类型</a></div>
			<div class="second-level-catalog"><a href="#2.8">2.8 org.w3c.dom.Node XML 事件</a></div>
			<div class="third-level-catalog"><a href="#2.8.1">2.8.1 模式定义xml事件</a></div>
			<div class="third-level-catalog"><a href="#2.8.2">2.8.2 无模式定义xml事件</a></div>
			<div class="third-level-catalog"><a href="#2.8.3">2.8.3 显示配置属性</a></div>
			<div class="second-level-catalog"><a href="#2.9">2.9 事件其他的表现形式</a></div>
			<div class="second-level-catalog"><a href="#2.10">2.10 更新，合并和版本事件（Versioning Events）</a></div>
			<div class="second-level-catalog"><a href="#2.11">2.11 粗粒度事件</a></div>
			<div class="second-level-catalog"><a href="#2.12">2.12 事件对象实例化并且被插入</a></div>
			<div class="second-level-catalog"><a href="#2.13">2.13 事件表现形式的比较</a></div>
			
			<p class="paragraph">
				这一章概述了表示模型和表示事件的不同方法。
			</p>
			
			<p class="paragraph">
				Esper  uses  the  term  event  type  to  describe  the  type  information  available  for  an  event representation.
			</p>
			
			<p class="paragraph">
				应用可以在启动的时候预先配置事件类型或者在运行时通过API或者EPL动态增加类型。<a href="#">16.4 配置项</a>有关启动时配置，<a href="#">15.3.8 运行时配置</a>有关运行时配置
			</p>
			
			<p class="paragraph">
				<code>create schema</code>语法允许在运行时定义一个事件。参照<a href="#">5.15 定义一个事件类型：create schema</a>
			</p>
			
			<p class="paragraph">
				<a href="#">15.6 事件和事件类型</a>解释了一个事件类型如何在EPL语句中可见，以及输出事件如何被投递。
			</p>
			<div class="first-level-catalog" id="2.1">2.1 基于java对象的事件</div>
			
			<p class="paragraph">
				一个事件是过去发生动作或者状态改变的一条不可变记录。事件属性记录了事件的状态信息。
			</p>
			
			<p class="paragraph">
				Esper中，一个事件可以用如下任何方式表示（NEsper .NET, 参考<a href="#">.NET 事件基础对象</a>）
			</p>
			
			表2.1. 事件底层java对象
			<table id="table2.1" class="mytable">
					<thead><td>Java类</td><td>描述</td></thead>
					<tbody>
						<tr><td><code>java.lang.Object</code></td><td>任何定义了getter方法符合JavaBeans约定的Java POJO；没有遵循JavaBeans约定的传统java类也可以用来声明事件。</td></tr>
						<tr><td><code>java.util.Map</code></td><td>Map事件实现了<code>java.util.Map</code>接口每一个key-value实体表示一个属性值。</td></tr>
						<tr><td><code>Object[] (array of object)</code></td><td>对象数组事件是一个对象数组，每一个数组元素是一个属性值。</td></tr>
						<tr><td><code>org.w3c.dom.Node</code></td><td>XML文档对象模型（DOM）</td></tr>
						<tr><td><code>org.apache.axiom.om.OMDocument or OMElement</code></td><td>XML-XML Streaming API（StAX）- Apache Axiom（EsperIO Package提供）</td></tr>
						<tr><td><code>Application classes</code></td><td>通过扩展API的插件式事件声明</td></tr>
					</tbody>
			</table>
			<p class="paragraph">
				Esper提供了多种选择来表示一个事件。没有必要通过创建一个java类来声明一个对象。
			</p>
			
			<p class="paragraph">
				事件表示有如下共性：
				<ol>
					<li>所有事件声明支持嵌套、下标、字典属性（mapped properties）（又叫属性表达式），后面会做更详细介绍。对于嵌套层次没有限制。</li>
					<li>所有事件声明提供事件类型元数据。包括嵌套属性。</li>
					<li>所有事件声明允许转换一个事件或者部分属性到一个新的事件。转换的意思指选择事件或者事件的嵌套的属性图，然后在将来的语句中查询事件的属性或者嵌套的属性图。Apache Axiom事件声明是一个例外，目前支持转换事件属性，但是不支持转换事件本身。</li>
					<li>Java Object，Map和Object-Array声明允许父类型。</li>
				</ol>
			</p>
			
			<p class="paragraph">
				所有的事件声明方式的API都是同样的，这一章会把微小的例外说明清楚。
			</p>
			<p class="paragraph">
				多种事件声明方式的好处如下：
			</p>
			
			<ol>
				<li>已经支持其中一种声明方式，处理前不需要变换成java对象</li>
				<li>Event  representations  are  exchangeable,  reducing  or  eliminating  the  need  to  change statements when the event representation changes.</li>
				<li>事件声明支持互操作，允许所有事件声明在同一个或者不同的语句中。</li>
				<li>多种事件声明方式是的可以平衡性能，易用性，转换和尝试使用已有的事件类型元数据导入或者声明事件。</li>
			</ol>
			<div class="first-level-catalog" id="2.2">2.2 事件属性</div>
			<p class="paragraph">
				事件属性捕获了事件的状态信息。事件属性是简单地、可索引地、可映射地和可嵌套地。下表列出了在事件表达式中不同的事件属性类型和他们的语法。这个语法允许语句深层次的JavaBean对象图，XML结构和Map事件。
			</p>
			表2.2. 事件属性类型
			<table id="table2.2" class="mytable">
					<thead><td>类型</td><td>描述</td><td>语法</td><td>实例</td></thead>
					<tbody>
						<tr><td>简单（Simple）</td><td>一个拥有单个值得属性</td><td><code>name</code></td><td><code>sensorId</code></td></tr>
						<tr><td>索引（Indexed）</td><td>被索引的属性存储了一个有序的集合（所有的都是同一个类型），可以通过非负的下边访问</td><td><code>name[index]</code></td><td><code>sensor[0]</code></td></tr>
						<tr><td>映射（Mapped）</td><td>一个映射地属性存储了一个和key关联的集合对象（所有的都是同一个类型）</td><td><code>name('key')</code></td><td><code>sensor('light')</code></td></tr>
						<tr><td>嵌套（Nested）</td><td>一个嵌套属性寄生于另一个属性</td><td><code>name.nestedname</code></td><td><code>sensor.value</code></td></tr>
					</tbody>
			</table>
			<p class="paragraph">
				组合使用也是有可能的。例如，一个可能的组合person.address('home').street[0]。
			</p>
			
			<div class="first-level-catalog" id="2.2.1">2.2.1. 转义符号</div>
			<p class="paragraph">
				如果你的应用使用 java.util.Map, Object[] 或者XML来表示事件，事件属性名称包含了“.”字符。“\”可以用来转义“\”属性名称。
			</p>
			<p class="paragraph">
				例如，如下所示的EPL语句，事件<code>MyEvent</code>中存在<code>part1.part2</code>:
			</p>
			<pre>select part1\.part2 from MyEvent</pre>
			<p class="paragraph">
				有时你的事件属性可能使用了EPL保留字符或者包含空格或者其他特殊字符。遇到这种情况你可以使用“`”来转义属性名称。下一个实例假设一个<code>Qutoe</code>事件有一个保留字为名称的<code>order</code>属性：
			</p>
			<pre>select `order`, price as `price.for.goods` from Quote</pre>
			<p class="paragraph">
				当转义映射或者索引属性的时候，确认“`”将映射地Key或者下表全部包含在内。
			</p>
			<p class="paragraph">
				下面的EPL语句的select列表中的属性名称，包含了空格（eg. candidate book），有特殊字符“'”（eg. children's  books）的是一个索引属性(e.g. children's  books[0]) ，并且一个映射地属性有一个保留关键字 (e.g. book select('isbn')):
			</p>
			<pre>select  `candidate  book`  ,  `children's  books`[0],  `book  select`('isbn')  from MyEventType</pre>
			
			<div class="first-level-catalog" id="2.2.2">2.2.2. 表达式作为key或者索引下标</div>
			
			<p class="paragraph">
				key或者索引下标表达式必须放在圆括号中。表达式类型的key必须返回<code>String</code>类型的值。使用表达式索引下标，表达式必须返回<code>int</code>类型。
			</p>
			
			<p class="paragraph">
				下面的例子使用java类来说明；同样的规则用在了所有的事件声明上。假定一个类定义了这些属性（为了代码简洁没有展现出getters）
			</p>
			
			<pre>
public class MyEventType {
	String myMapKey;
	int myIndexValue;
	int myInnerIndexValue;
	Map<String, InnerType> innerTypesMap; // mapped property
	InnerType[] innerTypesArray; // indexed property
}
public class InnerType {
	String name;
	int[] ids;
}
			</pre>
			
			<p class="paragraph">
				下面的EPL语句展示了作为key的表达式和索引下标的表达式。
			</p>
			
			<pre>
select innerTypesMap('somekey'),  // returns map value for 'somekey'
innerTypesMap(myMapKey),        // returns map value for myMapKey value (an expression)
innerTypesArray[1],             // returns array value at index 1
innerTypesArray(myIndexValue)   // returns array value at index myIndexValue (an expression)
from MyEventType
			</pre>
			
			<p class="paragraph">
				点操作符可以被用来调用通过映射或者索引下标属性返回的对象的方法。通过使用点操作符遵循链式调用按照“<a href="#">9.6 点操作符</a>”
			</p>
			
			<p class="paragraph">
				下面的EPL语句展示了点操作符和表达式作为key和下标索引：
			</p>
			<pre>
select innerTypesMap('somekey').ids[1],
innerTypesMap(myMapKey).getIds(myIndexValue),
innerTypesArray[1].ids[2],
innerTypesArray(myIndexValue).getIds(myInnerIndexValue)
from MyEventType
			</pre>
			
			<p class="paragraph">
				请注意如下的限制：
				<ol>
					<li>索引下标属性目前已经支持了表达式，并且需要时一个常量索引值。</li>
					<li>当和映射或者索引属性一起使用点操作符，如果使用了表达式作为key或者索引下标，必须遵循方法的链式调用语法。</li>
				</ol>
			</p>
			
			<div class="first-level-catalog" id="2.3">2.3 动态事件属性</div>
			<p class="paragraph">
				动态（非检查）属性指的是不需要再运行时定义的事件属性。这种属性在运行时被处理：这些属性提供了<a target="_blank" href="https://en.wikipedia.org/wiki/Duck_typing">duck typing</a>功能
			</p>
			
			<p class="paragraph">
				动态属性背后的想法是，对于一个底层的事件声明，我们不需要总是提前知道所有属性。我们会查询一个底层事件，那些在编译时所没有定义的事件属性。这个概念对于那些变现丰富，面向对象的领域模型是非常有用的。
			</p>
			
			<p class="paragraph">
			动态属性的语法包含属性名称和一个问号。索引下标和映射和嵌套属性也可以是动态属性。<br/><br/>
			表2.3. 事件属性类型
				<table>
					<thead><tr><td>类型</td><td>语法</td></tr></thead>
					<tbody>
						<tr><td>简单动态</td><td><code>name?</code></td></tr>
						<tr><td>索引下标动态</td><td><code>name[index]?</code></td></tr>
						<tr><td>映射动态</td><td><code>name('key')?</code></td></tr>
						<tr><td>内嵌动态</td><td><code>name?.nestedPropertyName</code></td></tr>
					</tbody>
				</table>
			</p>
			
			<p class="paragraph">
				动态属性在存在的情况下总是返回<code>java.lang.Object</code>类型；在不存在的情况下，总是返回<code>null</code>
			</p>
			
			<p class="paragraph">
				作为一个实例，考虑一个名为OrderEvent的事件，包含“item”属性。“item”属性是<code>Object</code>类型，并且保持了一个Service或者Product的引用。
			</p>
			
			<p class="paragraph">		  假设Service和Product类提供了一个“price”属性。通过动态属性，我们创建一个查询，这个查询可以覆盖到Service和Product的“price”属性。
			</p>
			
			<pre>
select item.price? from OrderEvent
			</pre>
			
			<p class="paragraph">
				第二个实例，假设Service类包含一个“serviceName”属性，这个属性在Product里面不存在。那么下面的查询语句，对于Service会返回属性值，对于Product会返回null。
			</p>
			
			<pre>
select item.serviceName? from OrderEvent
			</pre>
			
			<p class="paragraph">
				考虑这样的实例OrderEvent有许多实现类，其中有些类有“timestamp”属性。下面的查询返回那些实现了OrderEvent的“timestamp”属性值。
				<pre>
select timestamp? from OrderEvent
				</pre>
				上面的查询返回一个单列<code>Object</code>类型的值。“timestamp?”
			</p>
			
			<p class="paragraph">
				当动态属性被嵌套使用，那么所有下级属性都被认为是动态属性。下面的实例查询“detail”动态属性返回的“direction”属性：
				<pre>
select detail?.direction from OrderEvent
				</pre>
				和下面的是相等的
				<pre>
select detail?.direction? from OrderEvent
				</pre>
			</p>
			
			<p class="paragraph">
				通常与动态属性一起使用的有如下这些函数：
				<ul>
					<li><code>cast</code>函数将动态属性值（或者值表达式）转换成指定类型。</li>
					<li><code>exists</code>函数通过返回<code>true</code>或者<code>false</code>来判断是否动态属性值存在。</li>
					<li><code>instanceof</code>函数检查动态属性值是否是给定类型的。</li>
					<li><code>typeof</code>函数返回<code></code></li>
				</ul>
				动态属性如下声明方式都是支持的：Java-Objects，Map，Object-array和DOM事件。
			</p>
			
			<div class="first-level-catalog" id="2.4">2.4 片段和片段类型</div>
			
			<p class="paragraph">
				一个事件的属性可以也是事件。Esper为这种类型的事件使用术语片段和片段类型。最好的实例是一个模式匹配两个或者更多事件，并且输出事件包含匹配的事件作为片段。换句话说，输出事件可以是有进一步的事件和片段组成的组合事件。
			</p>
			
			<p class="paragraph">
				片段和类型元数据可以允许应用程序去访问组合事件，在不使用java反射API的情况下，并且降低对于底层事件声明的耦合。API会在<a href="#">15.6 事件和事件类型</a>进一步描述。
			</p>
			
			<div class="first-level-catalog" id="2.5">2.5  Plain-Old Java Object 事件</div>
			
			<p class="paragraph">
				NEsper请看<a href="#">.NET Object Events</a>
			</p>
			
			<p class="paragraph">
				Plain-old  Java  object指的是通过getter函数暴露时间属性的对象实例。事件类或者接口不用必须满足JavaBean定义；然而由于Esper引擎包含事件属性，JavaBean的getter函数必须被声明或者一个访问方式和访问函数可能通过配置进行定义。
			</p>
			<p class="paragraph">
				Esper支持JavaBeans风格事件类，这些类可以扩展一个超类或者实现一个或者更多的接口。Esper事件模式和EPL语句可以引用Java接口类和抽象类。
			</p>
			<p class="paragraph">
				由于事件是记录一个过去的状态改变或者动作，所以相关的事件属性不可以改变。这不是硬性规定，esper也接受可变对象。
			</p>
			<p class="paragraph">			
				不需要实现<code>hashCode</code>和<code>equals</code>函数。这连个函数不会影响Epser引擎的行为。
			</p>
			<p class="paragraph">
				请看<a href="#">16章，配置</a>那么些没有遵循javaBean规范约定，需要额外的进行配置。通过配置也可以实现控制属性值大小写敏感。相关章节<a href="#" >16.4.1.3 非JavaBean和遗留java类</a>
			</p>
			
			<div class="first-level-catalog" id="2.5.1">2.5.1. java对象事件属性</div>
			<p class="paragraph">
				前面提到，不同的属性类型被标准JavaBean定义的不同的属性类型支持，一些其他的被Esper单独支持.
				<ul>
					<li><code>Simple</code>——单值属性。底层也许是一个java原生类型，或者一个更复杂java对象。</li>
					<li><code>Indexed</code>——可索引属性存储一个有序的对象集合，可以通过非负的整数来访问单个对象。</li>
					<li><code>Mapped</code>——作为标准JavaBeans的扩展，Esper任何属性都可以被当成键值对来处理。</li>
					<li><code>Nexted</code>——嵌套的属性是一个寄生于其他java对象的属性。</li>
				</ul>
			</p>
			<p class="paragraph">
				如下，假设有一个<code>NewEmployeeEvent</code>事件类。这个例子的Mapped和Indexed属性返回java对象，但是也返回java原生类型。<code>Address</code>对象和<code>Employee</code>是nested类型的。他们包含各自的属性，例如街道名称和员工姓名。
				<pre>
public class NewEmployeeEvent {
	public String getFirstName();
	public Address getAddress(String type);
	public Employee getSubordinate(int index);
	public Employee[] getAllSubordinates();
}				</pre>
				Simple事件属性需要一个getter函数返回属性值。在这个实例，<code>getFirstName</code>返回String类型的<code>firstName</code>。
			</p>
		<p class="paragraph">
			Indexed事件属性需要如下getter函数。接收integer类型参数，返回属性值，类似<code>getSubordinate</code>函数，或者一个返回Array，又或是一个实现了<code>Iterable</code>的类。如实例<code>getAllSubordinates</code>，返回了一个<code>Employee</code>数组，也可以返回<code>Iterable</code>。在一个EPL或者事件模式语句，通过<code>property[index]</code>语法实现属性访问。
		</p>
		<p class="paragraph">
			Mapped事件属性需要一个接收String类型key的getter函数，例如：<code>getAddress</code>函数。在EPL或者事件模式语句，通过<code>property('key')</code>语法访问mapped属性。
		</p>
		
		<p class="paragraph">
			Nested事件属性需要一个getter函数返回嵌套对象。<code>getAddress getSubordinate</code>函数返回嵌套对象是mapped和indexed属性。EPL或者事件模式语句，通过<code>property.nestedProperty</code>语法来访问。
		</p>
		
		<p class="paragraph">
			所有事件模式和EPL语句，允许使用indexed，mapped和nested属性（或者任意组合使用）。如下实例展示了在事件模式表达式中过滤器不同的组合的使用方式（每行是一个单独的EPL语句）。
		</p>
		<pre>
every NewEmployeeEvent(firstName='myName')
every NewEmployeeEvent(address('home').streetName='Park Avenue')
every NewEmployeeEvent(subordinate[0].name='anotherName')
every NewEmployeeEvent(allSubordinates[1].name='thatName')
every NewEmployeeEvent(subordinate[0].address('home').streetName='WaterStreet')
		</pre>
		
		<p class="paragraph">
			类似的，这种语法可以用在EPL语句中，任何需要需要事件属性名称出现的地方，select列表，where条件，或者join语句。
		</p>
		
		<pre>
select firstName, address('work'), subordinate[0].name, subordinate[1].name
from NewEmployeeEvent
where address('work').streetName = 'Park Ave'
		</pre>
		
		<div class="first-level-catalog" id="2.5.2">2.5.2. 属性名称</div>
		<p class="paragraph">
			属性名称符合java标准规范：<code>java.beans.Introspector</code>和函数<code>getBeanInfo</code>返回来自于getter函数的属性名称。另外，Esper提供了可配置的方式关闭属性名称大小写敏感。下标是一个getter函数和属性名称的实例：
			表2.4. JavaBeans-style getter函数和属性名称
			<table>
				<thead><tr><td>Method</td><td>Property Name</td><td>Example</td></tr></thead>
				<tbody>
					<tr><td>getPrice()</td><td><code>price</code></td><td><code>select price from MyEvent</code></td></tr>
					<tr><td>getNAME()</td><td><code>NAME</code></td><td><code>select NAME from MyEvent</code></td></tr>
					<tr><td>getItemDesc()</td><td><code>itemDesc</code></td><td><code>select itemDesc from MyEvent</code></td></tr>
					<tr><td>getQ()</td><td><code>q</code></td><td><code>select q from MyEvent</code></td></tr>
					<tr><td>getQN()</td><td><code>QN</code></td><td><code>select QN from MyEvent</code></td></tr>
					<tr><td>getqn()</td><td><code>qn</code></td><td><code>select qn from MyEvent</code></td></tr>
					<tr><td>gets()</td><td><code>s</code></td><td><code>select s from MyEvent</code></td></tr>
				</tbody>
			</table>	
		</p>
		
		<div class="first-level-catalog" id="2.5.3">2.5.3. 泛型</div>
		<p class="paragraph">
			当getter函数返回一个泛型是，例如<code>Iterable<MyEventData></code>或者<code>Map<String, MyEventData></code>，那么属性表达式可用通过泛型对象访问到属性。
			
			<pre>
public class NewEmployeeEvent {
	public String getName();
	public Iterable<EducationHistory> getEducation();
	public Map<String, Address> getAddresses();
}
			</pre>
			
			<pre>
select name, education, education[0].date, addresses('home').street
from NewEmployeeEvent				
			</pre>
		</p>
		
		<div class="first-level-catalog" id="2.5.4">2.5.4. Indexed和Mapped属性的Setter方法</div>
		<p class="paragraph">
			一个EPL语句可以通过类暴露的setter函数，更新一个事件的indexed和mapped属性。indexed属性的setter函数必须被命名为<code>set属性名称</code>，并且必须传入两个参数：分别为int和Object类型。mapped属性的setter函数必须被命名为<code>set属性名称</code>，并且必须传入两个参数：分别为String和Object类型。下面是一个事件的setter函数实例，props是一个mapped属性，array是一个indexed属性：
			<pre>
public class MyEvent {
	private Map props = new HashMap();
    private Object[] array = new Object[10];
    public void setProps(String name, Object value) {
		props.put(name, value);
    }
	public void setArray(int index, Object value) {
		array[index] = value;
	}
	// ... also provide regular JavaBean getters and setters for all properties  
			</pre>
		</p>
		
		<p class="paragraph">
			更新mapped和indexed属性值的语句实例：
			<pre>
update istream MyEventStream set props('key') = 'abc', array[2] = 100
			</pre>
		</p>
		
		<div class="first-level-catalog"><a href="#2.5.5">2.5.5 已知限制</a></div>
		<p class="paragraph">
			Esper为了快速访问事件属性，使用字节码生成技术。当字节码生成失败的时候，引擎会记录一个高级日志，并且使用java反射来读取属性。
			一个已知的限制是，当一个接口存在一个特殊类型的属性，并且实际事件返回一个子类对象。引擎记录一个告警日志，并且使用反射获取这个属性。
		</p>
		
		<div class="first-level-catalog"><a href="#2.6">2.6  java.util.Map事件</a></div>
		Nesper .NET <a href="#">C.8章节 IDictionary事件</a>
		<div class="first-level-catalog"><a href="#2.6.1">2.6.1  概述</a></div>
		<p class="paragraph">
			事件可以被实现了<code>java.util.Map</code>接口的对象表示。Map事件的属性可以通过<code>java.util.Map</code>接口的get函数来访问。
		</p>
		<p class="paragraph">
			和Object-array事件类型类似，Map事件可以方便的在运行时改变类型。
		</p>
		<p class="paragraph">
			一个给定的Map事件类型可以有一个或者多个上层类型，这些上层类型必须是Map事件类型。上层类型的所有属性都可以通过类型自身访问到。另外，anywhere within EPL that an event type name of a Map supertype is used, any of its Map subtypes and their subtypes match that expression.
		</p>
		
		<p class="paragraph">
			程序可以在运行时往Map事件增加属性，使用<code>updateMapEventType</code>。但是只能被增加，不能被修改和删除，嵌套事件也可以被增加。运行时配置也允许删除Map事件类型并且可以和新的类型信息一起增加回去。
		</p>
		<p class="paragraph">
			当你的程序通过提供一个类型名称配置了一个Map事件。在定义后面的Map或者Object-array事件类型的时候，可以使用这个类型作为属性类型或者数组的类型。
		</p>
		
		<p class="paragraph">
			Map事件中的一对多关系通过数组来表示。一个Map事件中的属性可能是原生类型数组，java对象数组，Map事件数组或者对象数组的数组。
		</p>
		
		<p class="paragraph">
			引擎通过<code>EPRuntime</code>接口中的<code>sendEvent(Map map, String eventTypeName)</code>函数可以处理<code>java.util.Map</code>事件。Map事件的键必须是<code> java.util.String</code>类型，这是为了引擎可以发现处理通过模式或者EPL语句定义的事件属性名称。
		</p>
		
		<p class="paragraph">
			引擎不会校验Map事件属性的名称或者值。程序应该保证被传入的对象复合<code>create schema</code>定义的属性名称和类型，又或是使用运行时或静态配置的事件类型。
		</p>
		
		<div class="first-level-catalog"><a href="#2.6.2">2.6.2  Map属性</a></div>
		
		<p class="paragraph">
			Map事件属性可以是任何类型。Map事件属性可以是java对象，或者<code>java.util.Map</code>(或者数组)，或者<code>Object[]</code>
			
			<ul>
				<li>java对象可以通过nested，indexed，mapped以及之前提到的动态属性来查询；</li>
				<li>Map属性允许嵌套任意深度，因此可以被用来表示负责信息。nexted，indexed，mapped和动态属性语法可以被用来查询复杂类型；</li>
				<li><code>Object[]</code>属性允许嵌套任意深度。nested，indexed，mapped和动态属性语法可以被用来查询复杂类型的事件。</li>
			</ul>
		</p>
    </div>
	<div class="footer">
		
	</div>
  </body>
</html>
